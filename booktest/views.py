"""GET     /books/         提供所有记录POST    /books/         新增一条记录GET     /books/<pk>/    提供指定id的记录PUT     /books/<pk>/    修改指定id的记录DELETE  /books/<pk>/    删除指定id的记录响应数据    JSON# 列表视图: 路由后面没有pk/ID# 详情视图: 路由后面 pk/ID"""from django.views import Viewfrom django.http import HttpResponse, JsonResponseimport jsonfrom rest_framework.viewsets import ViewSet, GenericViewSet, ReadOnlyModelViewSet, ModelViewSetfrom rest_framework import status, viewsetsfrom rest_framework.viewsets import ModelViewSet# from booktest.serializers import BookInfoSerializer, HeroInfoSerializerfrom booktest.models import BookInfo, HeroInfofrom booktest.serializers import BookInfoModelSerializer"""以下是继承View的视图"""# class BookListView(View):#     """列表视图"""##     def get(self, request):#         """查询所有图书接口"""#         # 1.查询出所有图书模型#         books = BookInfo.objects.all()#         # 2.遍历查询集,取出里面的每个书籍模型对象,把模型对象转换成字典#         # 定义一个列表变量用来保存所个字典#         book_list = []#         for book in books:#             book_dict = {#                 'id': book.id,#                 'btitle': book.btitle,#                 'bpub_date': book.bpub_date,#                 'bread': book.bread,#                 'bcomment': book.bcomment,#                 'image': book.image.url if book.image else ''  # None.url#             }#             book_list.append(book_dict)  # 将转换好的字典添加到列表中#         # 3.响应#         return JsonResponse(book_list, safe=False)##     def post(self, request):#         """新增图书接口"""#         # 获取前端传入的请求体数据(json) request.body#         json_str_bytes = request.body#         # 把bytes类型的json字符串转换成json_str#         json_str = json_str_bytes.decode()#         # 利用json.loads将json字符串转换成json(字典/列表)#         book_dict = json.loads(json_str)##         # 创建模型对象并保存(把字典转换成模型并存储)#         book = BookInfo(#             btitle=book_dict['btitle'],#             bpub_date=book_dict['bpub_date']#         )#         book.save()##         # 把新增的模型转换成字典#         json_dict = {#             'id': book.id,#             'btitle': book.btitle,#             'bpub_date': book.bpub_date,#             'bread': book.bread,#             'bcomment': book.bcomment,#             'image': book.image.url if book.image else ''  # None.url#         }#         # 响应(把新增的数据再响应回去, 201)#         return JsonResponse(json_dict, status=201)### class BookDetailView(View):#     """详情视图"""##     def get(self, request, pk):#         """查询指定某个图书接口"""#         # 1.获取出指定pk的那个模型对象#         try:#             book = BookInfo.objects.get(id=pk)#         except BookInfo.DoesNotExist:#             return HttpResponse({'message': '查询的数据不存在'}, status=404)#         # 2.模型对象转字典#         book_dict = {#             'id': book.id,#             'btitle': book.btitle,#             'bpub_date': book.bpub_date,#             'bread': book.bread,#             'bcomment': book.bcomment,#             'image': book.image.url if book.image else ''  # None.url#         }#         # 3.响应#         return JsonResponse(book_dict)##     def put(self, request, pk):#         """修改指定图书接口"""#         # 先查询要修改的模型对象#         try:#             book = BookInfo.objects.get(pk=pk)#         except BookInfo.DoesNotExist:#             return HttpResponse({'message': '要修改的数据不存在'}, status=404)#         # 获取前端传入的新数据(把数据转换成字典)#         json_str_bytes = request.body#         json_str = json_str_bytes.decode()#         book_dict = json.loads(json_str)##         # book_dict = json.loads(request.body.decode())#         # 重新给模型指定的属性赋值#         book.btitle = book_dict['btitle']#         book.bpub_date = book_dict['bpub_date']#         # 调用save方法进行修改操作#         book.save()#         # 把修改后的模型再转换成字典#         json_dict = {#             'id': book.id,#             'btitle': book.btitle,#             'bpub_date': book.bpub_date,#             'bread': book.bread,#             'bcomment': book.bcomment,#             'image': book.image.url if book.image else ''  # None.url#         }#         # 响应#         return JsonResponse(json_dict)##     def delete(self, request, pk):#         """删除指定图书接口"""#         # 获取要删除的模型对象#         try:#             book = BookInfo.objects.get(id=pk)#         except BookInfo.DoesNotExist:#             return HttpResponse({'message': '要删除的数据不存在'}, status=404)#         # 删除模型对象#         book.delete()  # 物理删除(真正从数据库中删除)#         # book.is_delete = True#         # book.save() (逻辑删除)#         # 响应: 删除时不需要有响应体但要指定状态码为 204#         return HttpResponse(status=204)"""以下是继承APIView的视图"""# from .serializers import BookInfoModelSerializer# from rest_framework.views import APIView# from rest_framework.response import Response### class BookListAPIView(APIView):#     """列表视图"""#     def get(self, request):#         """查询所有图书接口"""#         # 查询所有书籍#         books = BookInfo.objects.all()#         # 将查询的书籍序列化#         serializer = BookInfoModelSerializer(books, many=True)#         # 返回响应对象#         return Response(serializer.data)##     def post(self, request):#         """新增图书接口"""#         # 获取前端解析后的请求体数据#         data = request.data#         # 创建序列器进行反序列化#         serializer = BookInfoModelSerializer(data=data)#         # 序列化器效验#         serializer.is_valid(raise_exception=True)#         # 调用序列化器的save方法执行create方法#         serializer.save()#         # 返回响应对象#         return Response(serializer.data, status=status.HTTP_201_CREATED)### class BookDetailAPIView(APIView):#     """详情视图"""##     def get(self, request, pk):#         """查询指定某个图书接口"""#         # 查询pk指定的模型对象#         try:#             book = BookInfo.objects.get(id = pk)#         except BookInfo.DoesNotExist:#             return Response(status=status.HTTP_404_NOT_FOUND)#         # 创建序列化器进行序列化#         serializer = BookInfoModelSerializer(instance=book)#         # 返回响应对象#         return Response(serializer.data)##     def put(self, request, pk):#         """修改指定图书接口"""#         # 查询pk指定的模型对象#         try:#             book = BookInfo.objects.get(id=pk)#         except BookInfo.DoesNotExist:#             return Response(status=status.HTTP_404_NOT_FOUND)#         # 创建序列化器进行反序列化#         serializer = BookInfoModelSerializer(instance=book,data=request.data)#         # 序列化器调用is_valid()进行校验#         serializer.is_valid(raise_exception=True)#         # 调用save()方法进行保存操作#         serializer.save()#         # 返回响应对象#         return Response(serializer.data)##     def delete(self, request, pk):#         """删除指定图书接口"""#         # 获取要删除的模型对象#         try:#             book = BookInfo.objects.get(id=pk)#         except BookInfo.DoesNotExist:#             return Response(status=status.HTTP_404_NOT_FOUND)#         # 删除模型对象#         book.delete()  # 物理删除(真正从数据库中删除)#         # book.is_delete = True#         # book.save() (逻辑删除)#         # 响应: 删除时不需要有响应体但要指定状态码为 204#         return Response(status=status.HTTP_204_NO_CONTENT)"""以下是继承GenericAPIView的视图"""# from .serializers import BookInfoModelSerializer# from rest_framework.generics import GenericAPIView,CreateAPIView# from rest_framework.response import Response### class BookListGenericAPIView(GenericAPIView):#     """列表视图"""#     # 获取BookInfo对象的所有查询集#     queryset = BookInfo.objects.all()#     # 指定所使用的序列化器#     serializer_class = BookInfoModelSerializer##     def get(self, request):#         """查询所有图书接口"""##         books = self.get_queryset()#         serializer = self.get_serializer(books, many=True)#         return Response(serializer.data)##     def post(self, request):#         """新增图书接口"""#         serializer = self.get_serializer(data=request.data)#         serializer.is_valid()#         serializer.save()#         return Response(serializer.data, status=status.HTTP_201_CREATED)### class BookDetailGenericAPIView(GenericAPIView):#     """详情视图"""#     # 获取BookInfo对象的所有查询集#     queryset = BookInfo.objects.all()#     # 指定所使用的序列化器#     serializer_class = BookInfoModelSerializer##     def get(self, request, pk):#         """查询指定某个图书接口"""#         book = self.get_object()#         serializer = BookInfoModelSerializer(book)#         return Response(serializer.data)##     def put(self, request, pk):#         """修改指定图书接口"""##         book = self.get_object()#         serializer = self.get_serializer(book, request.data)#         serializer.is_valid(raise_exception=True)#         serializer.save()#         return Response(serializer.data)##     def delete(self, request, pk):#         """删除指定图书接口"""#         book = self.get_object()#         book.delete()#         return Response(status=status.HTTP_204_NO_CONTENT)# from .serializers import BookInfoModelSerializerfrom rest_framework.generics import GenericAPIView, ListAPIView, CreateAPIView, RetrieveAPIView, DestroyAPIView, \    UpdateAPIViewfrom rest_framework.generics import ListCreateAPIView, RetrieveUpdateDestroyAPIViewfrom rest_framework.response import Response# class BookListGenericAPIView(CreateAPIView, ListAPIView, GenericAPIView):#     """列表视图"""#     # 获取BookInfo对象的所有查询集#     queryset = BookInfo.objects.all()#     # 指定所使用的序列化器#     serializer_class = BookInfoModelSerializer### class BookDetailGenericAPIView(RetrieveAPIView, DestroyAPIView, UpdateAPIView, GenericAPIView):#     """详情视图"""#     # 获取BookInfo对象的所有查询集#     queryset = BookInfo.objects.all()#     # 指定所使用的序列化器#     serializer_class = BookInfoModelSerializer# class BookListGenericAPIView(ListCreateAPIView, GenericAPIView):#     """列表视图"""#     # 获取BookInfo对象的所有查询集#     queryset = BookInfo.objects.all()#     # 指定所使用的序列化器#     serializer_class = BookInfoModelSerializer### class BookDetailGenericAPIView(RetrieveUpdateDestroyAPIView, GenericAPIView):#     """详情视图"""#     # 获取BookInfo对象的所有查询集#     queryset = BookInfo.objects.all()#     # 指定所使用的序列化器#     serializer_class = BookInfoModelSerializer"""以下是APIView的视图集"""# class BookInfoViewSet(viewsets.ViewSet):##     def list(self, request):#         books = BookInfo.objects.all()#         serializer = BookInfoModelSerializer(books, many=True)#         return Response(serializer.data)##     def retrieve(self, request, pk=None):#         try:#             books = BookInfo.objects.get(id=pk)#         except BookInfo.DoesNotExist:#             return Response(status=status.HTTP_404_NOT_FOUND)#         serializer = BookInfoModelSerializer(books)#         return Response(serializer.data)"""以下是GenericAPIView的视图集"""from rest_framework import mixinsfrom rest_framework.viewsets import GenericViewSetfrom rest_framework.decorators import actionfrom rest_framework.viewsets import ModelViewSetclass BookInfoViewSet(ModelViewSet):    queryset = BookInfo.objects.all()    serializer_class = BookInfoModelSerializer    @action(methods=['get'], detail=False)    def latest(self, request):        """        返回最新的图书信息        """        book = BookInfo.objects.latest('id')        serializer = self.get_serializer(book)        return Response(serializer.data)    @action(methods=['put'], detail=True)    def read(self, request, pk):        """        修改图书的阅读量数据        """        book = self.get_object()        book.bread = request.data.get('bread')        book.save()        serializer = self.get_serializer(book)        return Response(serializer.data)