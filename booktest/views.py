"""GET     /books/         提供所有记录POST    /books/         新增一条记录GET     /books/<pk>/    提供指定id的记录PUT     /books/<pk>/    修改指定id的记录DELETE  /books/<pk>/    删除指定id的记录响应数据    JSON# 列表视图: 路由后面没有pk/ID# 详情视图: 路由后面 pk/ID"""from django.views import Viewfrom django.http import HttpResponse, JsonResponseimport jsonfrom rest_framework.viewsets import ModelViewSetfrom .models import BookInfofrom .serializers import BookInfoSerializerclass BookListView(View):    """列表视图"""    def get(self, request):        """查询所有图书接口"""        # 1.查询出所有图书模型        books = BookInfo.objects.all()        # 2.遍历查询集,取出里面的每个书籍模型对象,把模型对象转换成字典        # 定义一个列表变量用来保存所个字典        book_list = []        for book in books:            book_dict = {                'id': book.id,                'btitle': book.btitle,                'bpub_date': book.bpub_date,                'bread': book.bread,                'bcomment': book.bcomment,                'image': book.image.url if book.image else ''  # None.url            }            book_list.append(book_dict)  # 将转换好的字典添加到列表中        # 3.响应        return JsonResponse(book_list, safe=False)    def post(self, request):        """新增图书接口"""        # 获取前端传入的请求体数据(json) request.body        json_str_bytes = request.body        # 把bytes类型的json字符串转换成json_str        json_str = json_str_bytes.decode()        # 利用json.loads将json字符串转换成json(字典/列表)        book_dict = json.loads(json_str)        # 创建模型对象并保存(把字典转换成模型并存储)        book = BookInfo(            btitle=book_dict['btitle'],            bpub_date=book_dict['bpub_date']        )        book.save()        # 把新增的模型转换成字典        json_dict = {            'id': book.id,            'btitle': book.btitle,            'bpub_date': book.bpub_date,            'bread': book.bread,            'bcomment': book.bcomment,            'image': book.image.url if book.image else ''  # None.url        }        # 响应(把新增的数据再响应回去, 201)        return JsonResponse(json_dict, status=201)class BookDetailView(View):    """详情视图"""    def get(self, request, pk):        """查询指定某个图书接口"""        # 1.获取出指定pk的那个模型对象        try:            book = BookInfo.objects.get(id=pk)        except BookInfo.DoesNotExist:            return HttpResponse({'message': '查询的数据不存在'}, status=404)        # 2.模型对象转字典        book_dict = {            'id': book.id,            'btitle': book.btitle,            'bpub_date': book.bpub_date,            'bread': book.bread,            'bcomment': book.bcomment,            'image': book.image.url if book.image else ''  # None.url        }        # 3.响应        return JsonResponse(book_dict)    def put(self, request, pk):        """修改指定图书接口"""        # 先查询要修改的模型对象        try:            book = BookInfo.objects.get(pk=pk)        except BookInfo.DoesNotExist:            return HttpResponse({'message': '要修改的数据不存在'}, status=404)        # 获取前端传入的新数据(把数据转换成字典)        json_str_bytes = request.body        json_str = json_str_bytes.decode()        book_dict = json.loads(json_str)        # book_dict = json.loads(request.body.decode())        # 重新给模型指定的属性赋值        book.btitle = book_dict['btitle']        book.bpub_date = book_dict['bpub_date']        # 调用save方法进行修改操作        book.save()        # 把修改后的模型再转换成字典        json_dict = {            'id': book.id,            'btitle': book.btitle,            'bpub_date': book.bpub_date,            'bread': book.bread,            'bcomment': book.bcomment,            'image': book.image.url if book.image else ''  # None.url        }        # 响应        return JsonResponse(json_dict)    def delete(self, request, pk):        """删除指定图书接口"""        # 获取要删除的模型对象        try:            book = BookInfo.objects.get(id=pk)        except BookInfo.DoesNotExist:            return HttpResponse({'message': '要删除的数据不存在'}, status=404)        # 删除模型对象        book.delete()  # 物理删除(真正从数据库中删除)        # book.is_delete = True        # book.save() (逻辑删除)        # 响应: 删除时不需要有响应体但要指定状态码为 204        return HttpResponse(status=204)class BookInfoViewSet(ModelViewSet):    """定义视图集"""    # 指定查询集    queryset = BookInfo.objects.all()    # 指定序列化器    serializer_class = BookInfoSerializerfrom booktest.serializers import BookInfoSerializer, HeroInfoSerializerfrom booktest.models import BookInfo, HeroInfo# book = BookInfo.objects.get(id=1)# s = BookInfoSerializer(instance=book)  # 创建序列化器对象,并序列化# s.data   # 获取序列化后的数据## qs = BookInfo.objects.all()# s1 = BookInfoSerializer(instance=qs, many=True)# s1.data"""[{},{},]序列化单个heroinfo 将它关联的英雄也序列化出来"""# hero = HeroInfo.objects.get(id=1)# serializer = HeroInfoSerializer(instance=hero)# serializer.datadata = {    'btitle': '三国',    'bpub_date': '1991-11-11'}serializer = BookInfoSerializer(data=data)serializer.is_valid()  # 调用序列化器的校验方法 True或Falseserializer.is_valid(raise_exception=True)  # raise_exception=True如果多指定这个 将来校验出错后,会自动抛出错误信息serializer.errors  # 获取校验的错误信息serializer.validated_data  # 获取反序列化校验后的数据还是字典